import os
import hashlib 
import time
from tqdm import tqdm
from sage.all import *
from sage.modules.free_module_integer import IntegerLattice
from pwn import *

conn = remote("13.209.188.120", 9003)

def Babai_CVP(mat, target):
	M = IntegerLattice(mat, lll_reduce=True).reduced_basis
	G = M.gram_schmidt()[0]
	diff = target
	for i in reversed(range(G.nrows())):
		diff -=  M[i] * ((diff * G[i]) / (G[i] * G[i])).round()
	return target - diff

def solve(mat, lb, ub, weight = None):
	num_var  = mat.nrows()
	num_ineq = mat.ncols()

	max_element = 0 
	for i in range(num_var):
		for j in range(num_ineq):
			max_element = max(max_element, abs(mat[i, j]))

	if weight == None:
		weight = num_ineq * max_element

    # sanity checker
	if len(lb) != num_ineq:
		print("Fail: len(lb) != num_ineq")
		return

	if len(ub) != num_ineq:
		print("Fail: len(ub) != num_ineq")
		return

	for i in range(num_ineq):
		if lb[i] > ub[i]:
			print("Fail: lb[i] > ub[i] at index", i)
			return

    # heuristic for number of solutions
	DET = 0

	if num_var == num_ineq:
		DET = abs(mat.det())
		num_sol = 1
		for i in range(num_ineq):
			num_sol *= (ub[i] - lb[i])
		if DET == 0:
			print("Zero Determinant")
		else:
			num_sol //= DET
			# + 1 added in for the sake of not making it zero...
			print("Expected Number of Solutions : ", num_sol + 1)

	# scaling process begins
	max_diff = max([ub[i] - lb[i] for i in range(num_ineq)])
	applied_weights = []

	for i in range(num_ineq):
		ineq_weight = weight if lb[i] == ub[i] else max_diff // (ub[i] - lb[i])
		applied_weights.append(ineq_weight)
		for j in range(num_var):
			mat[j, i] *= ineq_weight
		lb[i] *= ineq_weight
		ub[i] *= ineq_weight

	# Solve CVP
	target = vector([(lb[i] + ub[i]) // 2 for i in range(num_ineq)])
	result = Babai_CVP(mat, target)

	for i in range(num_ineq):
		if (lb[i] <= result[i] <= ub[i]) == False:
			print("Fail : inequality does not hold after solving")
			break
    
    # recover x
	fin = None

	if DET != 0:
		mat = mat.transpose()
		fin = mat.solve_right(result)
	
	## recover your result
	return result, applied_weights, fin

def inner_product(u, v):
    assert len(u) == len(v)
    res = 0
    for a, b in zip(u, v):
        res += a * b
    return res

def solve_generator_1():
    for _ in tqdm(range(64)):
        lines = []
        for i in range(20):
            lines.append(b"0")
            lines.append(str(1 << i).encode())
        conn.sendlines(lines)
        res = conn.recvlines(20)
        conn.sendline(b"1")
        if b"1" in res:
            conn.sendline(b"1")
        else:
            conn.sendline(b"0")

def solve_generator_2():
    for _ in tqdm(range(64)):
        cnt = [0] * 5        
        lines = []
        for i in range(0, 6000):
            lines.append(b"0")
            lines.append(str(i).encode())
        conn.sendlines(lines)
        res = conn.recvlines(6000)
        for i in range(0, 6000):
            cnt[int(res[i])] += 1
        conn.sendline(b"1")
        if max(cnt) > 1310:
            conn.sendline(b"0")
        else:
            conn.sendline(b"1")
  
def solve_generator_3():
    idx = []
    for i in range(64):
        idx.append([0] * 64)
    cur = 64
    for i in range(64):
        for j in range(i, 64):
            idx[i][j] = cur
            cur += 1
    M = []
    target = []
    lines = []
    for i in range(6000):
        lines.append(b"0")
        lines.append(str(i).encode())
    conn.sendlines(lines)
    res = conn.recvlines(6000)
    for i in tqdm(range(6000)):
        x = int.from_bytes(hashlib.sha256(str(i).encode()).digest(), "big")
        hashed = [0] * 64
        for j in range(64):
            hashed[j] = x % 5
            x = x // 5
        if int(res[i]) == 0:
            continue
        vec = [0] * 2144
        for j in range(64):
            vec[j] += hashed[j]
            vec[idx[j][j]] += hashed[j] ** 2
            for k in range(j+1, 64):
                vec[idx[j][k]] += 2 * hashed[j] * hashed[k]
        M.append(vec)
        target.append(2)
    M = Matrix(GF(5), M)
    target = vector(GF(5), target)
    res = M.solve_right(target)

    conn.sendline(b"1")
    for i in range(64):
        conn.sendline(str(res[i]).encode())   

def solve_generator_4():
    p = int(conn.recvline())
    q = int(conn.recvline())
    DATA = 33
    LEN = 16
    M = Matrix(ZZ, DATA + LEN, DATA + LEN)
    lb = [0] * (DATA + LEN)
    ub = [0] * (DATA + LEN)
    lines = []
    for i in range(DATA):
        lines.append(b"0")
        lines.append(str(i).encode())
    conn.sendlines(lines)
    res = conn.recvlines(DATA)
    for i in range(DATA):
        x = hashlib.sha256(str(i).encode()).digest()
        hashed = []
        for _ in range(LEN):
            hashed.append(int.from_bytes(x, "big"))
            x = hashlib.sha256(x).digest()
        result = int(res[i])
        lb[i] = result - q
        ub[i] = result
        for j in range(LEN):
            M[j, i] = hashed[j]
        M[i + LEN, i] = p
    for i in range(LEN):
        M[i, i + DATA] = 1
        lb[i + DATA] = 0
        ub[i + DATA] = p
    _, _, fin = solve(M, lb, ub)
    conn.sendline(b"1")
    for i in range(LEN):
        conn.sendline(str(fin[i]).encode())
    
st = time.time()

print(conn.recvline())
solve_generator_1()
print("check1")

print(conn.recvline())
solve_generator_2()
print("check2")

print(conn.recvline())
solve_generator_3()
print("check3")

print(conn.recvline())
solve_generator_4()
print("check4")

en = time.time()

print("time :", en - st)
print(conn.recvline())